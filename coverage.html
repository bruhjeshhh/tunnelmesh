
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>tunnelmesh-server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tunnelmesh/tunnelmesh/cmd/tunnelmesh-server/main.go (0.0%)</option>
				
				<option value="file1">github.com/tunnelmesh/tunnelmesh/cmd/tunnelmesh/main.go (0.0%)</option>
				
				<option value="file2">github.com/tunnelmesh/tunnelmesh/internal/config/config.go (96.2%)</option>
				
				<option value="file3">github.com/tunnelmesh/tunnelmesh/internal/config/keys.go (79.2%)</option>
				
				<option value="file4">github.com/tunnelmesh/tunnelmesh/internal/coord/client.go (69.1%)</option>
				
				<option value="file5">github.com/tunnelmesh/tunnelmesh/internal/coord/server.go (74.8%)</option>
				
				<option value="file6">github.com/tunnelmesh/tunnelmesh/internal/dns/resolver.go (96.5%)</option>
				
				<option value="file7">github.com/tunnelmesh/tunnelmesh/internal/tunnel/tunnel.go (33.3%)</option>
				
				<option value="file8">github.com/tunnelmesh/tunnelmesh/internal/udpenc/encoder.go (87.2%)</option>
				
				<option value="file9">github.com/tunnelmesh/tunnelmesh/pkg/proto/messages.go (87.2%)</option>
				
				<option value="file10">github.com/tunnelmesh/tunnelmesh/testutil/testutil.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// tunnelmesh-server is the coordination server for the tunnelmesh network.
package main

import (
        "fmt"
        "os"
        "os/signal"
        "syscall"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/tunnelmesh/tunnelmesh/internal/config"
        "github.com/tunnelmesh/tunnelmesh/internal/coord"
)

var (
        Version   = "dev"
        Commit    = "unknown"
        BuildTime = "unknown"
)

var (
        cfgFile  string
        logLevel string
)

func main() <span class="cov0" title="0">{
        rootCmd := &amp;cobra.Command{
                Use:   "tunnelmesh-server",
                Short: "TunnelMesh coordination server",
                Long: `TunnelMesh server manages peer registration and discovery for the mesh network.

It provides a REST API for peers to:
- Register and deregister from the mesh
- Discover other peers
- Get DNS records for .mesh hostnames`,
                RunE: runServer,
        }

        rootCmd.PersistentFlags().StringVarP(&amp;cfgFile, "config", "c", "", "config file path")
        rootCmd.PersistentFlags().StringVarP(&amp;logLevel, "log-level", "l", "info", "log level (debug, info, warn, error)")

        versionCmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Print version information",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Printf("tunnelmesh-server %s\n", Version)
                        fmt.Printf("  Commit:     %s\n", Commit)
                        fmt.Printf("  Build Time: %s\n", BuildTime)
                }</span>,
        }
        <span class="cov0" title="0">rootCmd.AddCommand(versionCmd)

        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func runServer(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        setupLogging()

        if cfgFile == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("config file required (use --config)")
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadServerConfig(cfgFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid config: %w", err)
        }</span>

        <span class="cov0" title="0">srv, err := coord.NewServer(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create server: %w", err)
        }</span>

        // Handle shutdown signals
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                log.Info().Msg("shutting down...")
                os.Exit(0)
        }</span>()

        <span class="cov0" title="0">log.Info().
                Str("listen", cfg.Listen).
                Str("mesh_cidr", cfg.MeshCIDR).
                Str("domain", cfg.DomainSuffix).
                Msg("starting tunnelmesh server")

        return srv.ListenAndServe()</span>
}

func setupLogging() <span class="cov0" title="0">{
        zerolog.TimeFieldFormat = zerolog.TimeFormatUnix

        level, err := zerolog.ParseLevel(logLevel)
        if err != nil </span><span class="cov0" title="0">{
                level = zerolog.InfoLevel
        }</span>
        <span class="cov0" title="0">zerolog.SetGlobalLevel(level)

        // Use pretty console output
        log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// tunnelmesh is the peer daemon for the tunnelmesh network.
package main

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "path/filepath"
        "syscall"
        "time"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/tunnelmesh/tunnelmesh/internal/config"
        "github.com/tunnelmesh/tunnelmesh/internal/coord"
        meshdns "github.com/tunnelmesh/tunnelmesh/internal/dns"
        "github.com/tunnelmesh/tunnelmesh/pkg/proto"
)

var (
        Version   = "dev"
        Commit    = "unknown"
        BuildTime = "unknown"
)

var (
        cfgFile   string
        logLevel  string
        serverURL string
        authToken string
        nodeName  string
)

func main() <span class="cov0" title="0">{
        rootCmd := &amp;cobra.Command{
                Use:   "tunnelmesh",
                Short: "TunnelMesh peer daemon",
                Long: `TunnelMesh creates encrypted P2P tunnels between peers using SSH.

It connects to a coordination server for peer discovery and establishes
direct SSH tunnels to other peers in the mesh network.`,
        }

        rootCmd.PersistentFlags().StringVarP(&amp;cfgFile, "config", "c", "", "config file path")
        rootCmd.PersistentFlags().StringVarP(&amp;logLevel, "log-level", "l", "info", "log level")

        // Join command
        joinCmd := &amp;cobra.Command{
                Use:   "join",
                Short: "Join the mesh network",
                Long:  "Register with the coordination server and start the mesh daemon",
                RunE:  runJoin,
        }
        joinCmd.Flags().StringVarP(&amp;serverURL, "server", "s", "", "coordination server URL")
        joinCmd.Flags().StringVarP(&amp;authToken, "token", "t", "", "authentication token")
        joinCmd.Flags().StringVarP(&amp;nodeName, "name", "n", "", "node name")
        rootCmd.AddCommand(joinCmd)

        // Status command
        statusCmd := &amp;cobra.Command{
                Use:   "status",
                Short: "Show mesh status",
                RunE:  runStatus,
        }
        rootCmd.AddCommand(statusCmd)

        // Peers command
        peersCmd := &amp;cobra.Command{
                Use:   "peers",
                Short: "List mesh peers",
                RunE:  runPeers,
        }
        rootCmd.AddCommand(peersCmd)

        // Resolve command
        resolveCmd := &amp;cobra.Command{
                Use:   "resolve &lt;hostname&gt;",
                Short: "Resolve a mesh hostname",
                Args:  cobra.ExactArgs(1),
                RunE:  runResolve,
        }
        rootCmd.AddCommand(resolveCmd)

        // Leave command
        leaveCmd := &amp;cobra.Command{
                Use:   "leave",
                Short: "Leave the mesh network",
                RunE:  runLeave,
        }
        rootCmd.AddCommand(leaveCmd)

        // Version command
        versionCmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Print version information",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Printf("tunnelmesh %s\n", Version)
                        fmt.Printf("  Commit:     %s\n", Commit)
                        fmt.Printf("  Build Time: %s\n", BuildTime)
                }</span>,
        }
        <span class="cov0" title="0">rootCmd.AddCommand(versionCmd)

        // Init command - generate keys
        initCmd := &amp;cobra.Command{
                Use:   "init",
                Short: "Initialize tunnelmesh (generate keys)",
                RunE:  runInit,
        }
        rootCmd.AddCommand(initCmd)

        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func runInit(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        setupLogging()

        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get home dir: %w", err)
        }</span>

        <span class="cov0" title="0">keyDir := filepath.Join(homeDir, ".tunnelmesh")
        keyPath := filepath.Join(keyDir, "id_ed25519")

        // Check if key already exists
        if _, err := os.Stat(keyPath); err == nil </span><span class="cov0" title="0">{
                log.Info().Str("path", keyPath).Msg("keys already exist")
                return nil
        }</span>

        <span class="cov0" title="0">if err := config.GenerateKeyPair(keyPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generate keys: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info().Str("path", keyPath).Msg("keys generated")
        log.Info().Str("path", keyPath+".pub").Msg("public key")
        return nil</span>
}

func runJoin(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        setupLogging()

        cfg, err := loadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Override with flags
        <span class="cov0" title="0">if serverURL != "" </span><span class="cov0" title="0">{
                cfg.Server = serverURL
        }</span>
        <span class="cov0" title="0">if authToken != "" </span><span class="cov0" title="0">{
                cfg.AuthToken = authToken
        }</span>
        <span class="cov0" title="0">if nodeName != "" </span><span class="cov0" title="0">{
                cfg.Name = nodeName
        }</span>

        <span class="cov0" title="0">if cfg.Server == "" || cfg.AuthToken == "" || cfg.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("server, token, and name are required")
        }</span>

        // Ensure keys exist
        <span class="cov0" title="0">signer, err := config.EnsureKeyPairExists(cfg.PrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load keys: %w", err)
        }</span>

        <span class="cov0" title="0">pubKeyFP := config.GetPublicKeyFingerprint(signer.PublicKey())
        log.Info().Str("fingerprint", pubKeyFP).Msg("using SSH key")

        // Get local IPs
        publicIPs, privateIPs := proto.GetLocalIPs()
        log.Debug().
                Strs("public", publicIPs).
                Strs("private", privateIPs).
                Msg("detected local IPs")

        // Connect to coordination server
        client := coord.NewClient(cfg.Server, cfg.AuthToken)

        resp, err := client.Register(cfg.Name, pubKeyFP, publicIPs, privateIPs, cfg.SSHPort)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("register with server: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info().
                Str("mesh_ip", resp.MeshIP).
                Str("mesh_cidr", resp.MeshCIDR).
                Str("domain", resp.Domain).
                Msg("joined mesh network")

        // Start DNS resolver if enabled
        var resolver *meshdns.Resolver
        if cfg.DNS.Enabled </span><span class="cov0" title="0">{
                resolver = meshdns.NewResolver(resp.Domain, cfg.DNS.CacheTTL)

                // Initial DNS sync
                if err := syncDNS(client, resolver); err != nil </span><span class="cov0" title="0">{
                        log.Warn().Err(err).Msg("failed to sync DNS")
                }</span>

                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        if err := resolver.ListenAndServe(cfg.DNS.Listen); err != nil </span><span class="cov0" title="0">{
                                log.Error().Err(err).Msg("DNS server error")
                        }</span>
                }()
                <span class="cov0" title="0">log.Info().Str("listen", cfg.DNS.Listen).Msg("DNS server started")</span>
        }

        // Start heartbeat loop
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        go heartbeatLoop(ctx, client, cfg.Name, pubKeyFP, resolver)

        // Wait for shutdown signal
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        &lt;-sigChan
        log.Info().Msg("shutting down...")

        // Deregister
        if err := client.Deregister(cfg.Name); err != nil </span><span class="cov0" title="0">{
                log.Warn().Err(err).Msg("failed to deregister")
        }</span> else<span class="cov0" title="0"> {
                log.Info().Msg("deregistered from mesh")
        }</span>

        <span class="cov0" title="0">if resolver != nil </span><span class="cov0" title="0">{
                resolver.Shutdown()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func runStatus(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        setupLogging()
        fmt.Println("Status: Not implemented yet")
        fmt.Println("Use 'tunnelmesh peers' to list connected peers")
        return nil
}</span>

func runPeers(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        setupLogging()

        cfg, err := loadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client := coord.NewClient(cfg.Server, cfg.AuthToken)
        peers, err := client.ListPeers()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("list peers: %w", err)
        }</span>

        <span class="cov0" title="0">if len(peers) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No peers in mesh")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("%-20s %-15s %-20s %s\n", "NAME", "MESH IP", "PUBLIC IP", "LAST SEEN")
        fmt.Println("-------------------- --------------- -------------------- --------------------")

        for _, p := range peers </span><span class="cov0" title="0">{
                publicIP := "-"
                if len(p.PublicIPs) &gt; 0 </span><span class="cov0" title="0">{
                        publicIP = p.PublicIPs[0]
                }</span>
                <span class="cov0" title="0">lastSeen := p.LastSeen.Format("2006-01-02 15:04:05")
                fmt.Printf("%-20s %-15s %-20s %s\n", p.Name, p.MeshIP, publicIP, lastSeen)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func runResolve(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        setupLogging()

        cfg, err := loadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">hostname := args[0]

        client := coord.NewClient(cfg.Server, cfg.AuthToken)
        records, err := client.GetDNSRecords()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get DNS records: %w", err)
        }</span>

        <span class="cov0" title="0">for _, r := range records </span><span class="cov0" title="0">{
                if r.Hostname == hostname </span><span class="cov0" title="0">{
                        fmt.Printf("%s -&gt; %s\n", hostname, r.MeshIP)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("hostname not found: %s", hostname)</span>
}

func runLeave(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        setupLogging()

        cfg, err := loadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client := coord.NewClient(cfg.Server, cfg.AuthToken)
        if err := client.Deregister(cfg.Name); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("deregister: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info().Msg("left mesh network")
        return nil</span>
}

func loadConfig() (*config.PeerConfig, error) <span class="cov0" title="0">{
        if cfgFile != "" </span><span class="cov0" title="0">{
                return config.LoadPeerConfig(cfgFile)
        }</span>

        // Try default locations
        <span class="cov0" title="0">homeDir, _ := os.UserHomeDir()
        defaults := []string{
                filepath.Join(homeDir, ".tunnelmesh", "config.yaml"),
                "tunnelmesh.yaml",
                "peer.yaml",
        }

        for _, path := range defaults </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        return config.LoadPeerConfig(path)
                }</span>
        }

        // Return empty config with defaults
        <span class="cov0" title="0">return &amp;config.PeerConfig{
                SSHPort:    2222,
                PrivateKey: filepath.Join(homeDir, ".tunnelmesh", "id_ed25519"),
                TUN: config.TUNConfig{
                        Name: "tun-mesh0",
                        MTU:  1400,
                },
                DNS: config.DNSConfig{
                        Enabled:  true,
                        Listen:   "127.0.0.53:5353",
                        CacheTTL: 300,
                },
        }, nil</span>
}

func heartbeatLoop(ctx context.Context, client *coord.Client, name, pubKey string, resolver *meshdns.Resolver) <span class="cov0" title="0">{
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := client.Heartbeat(name, pubKey); err != nil </span><span class="cov0" title="0">{
                                log.Warn().Err(err).Msg("heartbeat failed")
                                continue</span>
                        }

                        // Sync DNS records
                        <span class="cov0" title="0">if resolver != nil </span><span class="cov0" title="0">{
                                if err := syncDNS(client, resolver); err != nil </span><span class="cov0" title="0">{
                                        log.Warn().Err(err).Msg("DNS sync failed")
                                }</span>
                        }
                }
        }
}

func syncDNS(client *coord.Client, resolver *meshdns.Resolver) error <span class="cov0" title="0">{
        records, err := client.GetDNSRecords()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">recordMap := make(map[string]string, len(records))
        for _, r := range records </span><span class="cov0" title="0">{
                recordMap[r.Hostname] = r.MeshIP
        }</span>

        <span class="cov0" title="0">resolver.UpdateRecords(recordMap)
        return nil</span>
}

func setupLogging() <span class="cov0" title="0">{
        zerolog.TimeFieldFormat = zerolog.TimeFormatUnix

        level, err := zerolog.ParseLevel(logLevel)
        if err != nil </span><span class="cov0" title="0">{
                level = zerolog.InfoLevel
        }</span>
        <span class="cov0" title="0">zerolog.SetGlobalLevel(level)

        log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package config handles configuration loading and validation for tunnelmesh.
package config

import (
        "fmt"
        "net"
        "os"
        "path/filepath"
        "strings"

        "gopkg.in/yaml.v3"
)

// ServerConfig holds configuration for the coordination server.
type ServerConfig struct {
        Listen       string `yaml:"listen"`
        AuthToken    string `yaml:"auth_token"`
        MeshCIDR     string `yaml:"mesh_cidr"`
        DomainSuffix string `yaml:"domain_suffix"`
}

// PeerConfig holds configuration for a peer node.
type PeerConfig struct {
        Name       string    `yaml:"name"`
        Server     string    `yaml:"server"`
        AuthToken  string    `yaml:"auth_token"`
        SSHPort    int       `yaml:"ssh_port"`
        PrivateKey string    `yaml:"private_key"`
        TUN        TUNConfig `yaml:"tun"`
        DNS        DNSConfig `yaml:"dns"`
}

// TUNConfig holds configuration for the TUN interface.
type TUNConfig struct {
        Name string `yaml:"name"`
        MTU  int    `yaml:"mtu"`
}

// DNSConfig holds configuration for the local DNS resolver.
type DNSConfig struct {
        Enabled  bool   `yaml:"enabled"`
        Listen   string `yaml:"listen"`
        CacheTTL int    `yaml:"cache_ttl"`
}

// LoadServerConfig loads server configuration from a YAML file.
func LoadServerConfig(path string) (*ServerConfig, error) <span class="cov8" title="4">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("read config file: %w", err)
        }</span>

        <span class="cov7" title="3">cfg := &amp;ServerConfig{}
        if err := yaml.Unmarshal(data, cfg); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("parse config file: %w", err)
        }</span>

        // Apply defaults
        <span class="cov4" title="2">if cfg.MeshCIDR == "" </span><span class="cov1" title="1">{
                cfg.MeshCIDR = "10.99.0.0/16"
        }</span>
        <span class="cov4" title="2">if cfg.DomainSuffix == "" </span><span class="cov1" title="1">{
                cfg.DomainSuffix = ".mesh"
        }</span>

        <span class="cov4" title="2">return cfg, nil</span>
}

// LoadPeerConfig loads peer configuration from a YAML file.
func LoadPeerConfig(path string) (*PeerConfig, error) <span class="cov7" title="3">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read config file: %w", err)
        }</span>

        <span class="cov7" title="3">cfg := &amp;PeerConfig{}
        if err := yaml.Unmarshal(data, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse config file: %w", err)
        }</span>

        // Apply defaults
        <span class="cov7" title="3">if cfg.SSHPort == 0 </span><span class="cov4" title="2">{
                cfg.SSHPort = 2222
        }</span>
        <span class="cov7" title="3">if cfg.TUN.Name == "" </span><span class="cov4" title="2">{
                cfg.TUN.Name = "tun-mesh0"
        }</span>
        <span class="cov7" title="3">if cfg.TUN.MTU == 0 </span><span class="cov4" title="2">{
                cfg.TUN.MTU = 1400
        }</span>
        <span class="cov7" title="3">if cfg.DNS.Listen == "" </span><span class="cov4" title="2">{
                cfg.DNS.Listen = "127.0.0.53:5353"
        }</span>
        <span class="cov7" title="3">if cfg.DNS.CacheTTL == 0 </span><span class="cov4" title="2">{
                cfg.DNS.CacheTTL = 300
        }</span>
        // DNS enabled by default
        <span class="cov7" title="3">if !cfg.DNS.Enabled &amp;&amp; cfg.DNS.Listen == "127.0.0.53:5353" </span><span class="cov4" title="2">{
                cfg.DNS.Enabled = true
        }</span>

        // Expand home directory in private key path
        <span class="cov7" title="3">if strings.HasPrefix(cfg.PrivateKey, "~/") </span><span class="cov1" title="1">{
                homeDir, err := os.UserHomeDir()
                if err == nil </span><span class="cov1" title="1">{
                        cfg.PrivateKey = filepath.Join(homeDir, cfg.PrivateKey[2:])
                }</span>
        }

        <span class="cov7" title="3">return cfg, nil</span>
}

// Validate checks if the server configuration is valid.
func (c *ServerConfig) Validate() error <span class="cov8" title="4">{
        if c.Listen == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("listen address is required")
        }</span>
        <span class="cov7" title="3">if c.AuthToken == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("auth_token is required")
        }</span>
        <span class="cov4" title="2">if c.MeshCIDR != "" </span><span class="cov4" title="2">{
                _, _, err := net.ParseCIDR(c.MeshCIDR)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid mesh_cidr: %w", err)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// Validate checks if the peer configuration is valid.
func (c *PeerConfig) Validate() error <span class="cov10" title="5">{
        if c.Name == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("name is required")
        }</span>
        <span class="cov8" title="4">if c.Server == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("server is required")
        }</span>
        <span class="cov7" title="3">if c.SSHPort &lt;= 0 || c.SSHPort &gt; 65535 </span><span class="cov1" title="1">{
                return fmt.Errorf("ssh_port must be between 1 and 65535")
        }</span>
        <span class="cov4" title="2">if c.TUN.MTU &lt; 576 || c.TUN.MTU &gt; 65535 </span><span class="cov1" title="1">{
                return fmt.Errorf("tun.mtu must be between 576 and 65535")
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "bufio"
        "crypto/ed25519"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/pem"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "golang.org/x/crypto/ssh"
)

// GenerateKeyPair generates a new ED25519 SSH key pair and saves it to disk.
// The private key is saved to privPath and public key to privPath.pub
func GenerateKeyPair(privPath string) error <span class="cov4" title="2">{
        // Generate ED25519 key pair
        pubKey, privKey, err := ed25519.GenerateKey(rand.Reader)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generate key pair: %w", err)
        }</span>

        // Marshal private key to OpenSSH format
        <span class="cov4" title="2">sshPubKey, err := ssh.NewPublicKey(pubKey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create SSH public key: %w", err)
        }</span>

        <span class="cov4" title="2">pemBlock, err := ssh.MarshalPrivateKey(privKey, "")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal private key: %w", err)
        }</span>

        // Encode PEM block to bytes
        <span class="cov4" title="2">pemBytes := pem.EncodeToMemory(pemBlock)

        // Ensure directory exists
        if err := os.MkdirAll(filepath.Dir(privPath), 0700); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create key directory: %w", err)
        }</span>

        // Write private key with restricted permissions
        <span class="cov4" title="2">if err := os.WriteFile(privPath, pemBytes, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write private key: %w", err)
        }</span>

        // Write public key
        <span class="cov4" title="2">pubPath := privPath + ".pub"
        pubBytes := ssh.MarshalAuthorizedKey(sshPubKey)
        if err := os.WriteFile(pubPath, pubBytes, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write public key: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

// LoadPrivateKey loads an SSH private key from disk.
func LoadPrivateKey(path string) (ssh.Signer, error) <span class="cov10" title="7">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("read private key: %w", err)
        }</span>

        <span class="cov8" title="5">signer, err := ssh.ParsePrivateKey(data)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("parse private key: %w", err)
        }</span>

        <span class="cov7" title="4">return signer, nil</span>
}

// LoadAuthorizedKeys loads a list of public keys from an authorized_keys file.
func LoadAuthorizedKeys(path string) ([]ssh.PublicKey, error) <span class="cov6" title="3">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open authorized_keys: %w", err)
        }</span>
        <span class="cov6" title="3">defer file.Close()

        var keys []ssh.PublicKey
        scanner := bufio.NewScanner(file)

        for scanner.Scan() </span><span class="cov7" title="4">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov6" title="3">pubKey, _, _, _, err := ssh.ParseAuthorizedKey([]byte(line))
                if err != nil </span><span class="cov0" title="0">{
                        // Skip invalid lines
                        continue</span>
                }
                <span class="cov6" title="3">keys = append(keys, pubKey)</span>
        }

        <span class="cov6" title="3">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read authorized_keys: %w", err)
        }</span>

        <span class="cov6" title="3">return keys, nil</span>
}

// EnsureKeyPairExists loads an existing key pair or generates a new one.
func EnsureKeyPairExists(privPath string) (ssh.Signer, error) <span class="cov4" title="2">{
        // Try to load existing key
        signer, err := LoadPrivateKey(privPath)
        if err == nil </span><span class="cov1" title="1">{
                return signer, nil
        }</span>

        // Generate new key pair if it doesn't exist
        <span class="cov1" title="1">if os.IsNotExist(err) || strings.Contains(err.Error(), "no such file") </span><span class="cov1" title="1">{
                if err := GenerateKeyPair(privPath); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("generate key pair: %w", err)
                }</span>
                <span class="cov1" title="1">return LoadPrivateKey(privPath)</span>
        }

        <span class="cov0" title="0">return nil, err</span>
}

// GetPublicKeyFingerprint returns the SHA256 fingerprint of an SSH public key.
func GetPublicKeyFingerprint(key ssh.PublicKey) string <span class="cov1" title="1">{
        hash := sha256.Sum256(key.Marshal())
        return "SHA256:" + base64.StdEncoding.EncodeToString(hash[:])
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package coord

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/tunnelmesh/tunnelmesh/pkg/proto"
)

// Client is a client for the coordination server.
type Client struct {
        baseURL   string
        authToken string
        client    *http.Client
}

// NewClient creates a new coordination client.
func NewClient(baseURL, authToken string) *Client <span class="cov6" title="5">{
        return &amp;Client{
                baseURL:   baseURL,
                authToken: authToken,
                client: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }
}</span>

// Register registers this peer with the coordination server.
func (c *Client) Register(name, publicKey string, publicIPs, privateIPs []string, sshPort int) (*proto.RegisterResponse, error) <span class="cov7" title="6">{
        req := proto.RegisterRequest{
                Name:       name,
                PublicKey:  publicKey,
                PublicIPs:  publicIPs,
                PrivateIPs: privateIPs,
                SSHPort:    sshPort,
        }

        body, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshal request: %w", err)
        }</span>

        <span class="cov7" title="6">resp, err := c.doRequest(http.MethodPost, "/api/v1/register", body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="6">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, c.parseError(resp)
        }</span>

        <span class="cov7" title="6">var result proto.RegisterResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decode response: %w", err)
        }</span>

        <span class="cov7" title="6">return &amp;result, nil</span>
}

// ListPeers returns a list of all registered peers.
func (c *Client) ListPeers() ([]proto.Peer, error) <span class="cov4" title="3">{
        resp, err := c.doRequest(http.MethodGet, "/api/v1/peers", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, c.parseError(resp)
        }</span>

        <span class="cov4" title="3">var result proto.PeerListResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decode response: %w", err)
        }</span>

        <span class="cov4" title="3">return result.Peers, nil</span>
}

// Heartbeat sends a heartbeat to maintain presence.
func (c *Client) Heartbeat(name, publicKey string) error <span class="cov1" title="1">{
        req := proto.HeartbeatRequest{
                Name:      name,
                PublicKey: publicKey,
        }

        body, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal request: %w", err)
        }</span>

        <span class="cov1" title="1">resp, err := c.doRequest(http.MethodPost, "/api/v1/heartbeat", body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return c.parseError(resp)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Deregister removes this peer from the mesh.
func (c *Client) Deregister(name string) error <span class="cov1" title="1">{
        resp, err := c.doRequest(http.MethodDelete, "/api/v1/peers/"+name, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return c.parseError(resp)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetDNSRecords returns the current DNS records.
func (c *Client) GetDNSRecords() ([]proto.DNSRecord, error) <span class="cov1" title="1">{
        resp, err := c.doRequest(http.MethodGet, "/api/v1/dns", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, c.parseError(resp)
        }</span>

        <span class="cov1" title="1">var result proto.DNSUpdateNotification
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decode response: %w", err)
        }</span>

        <span class="cov1" title="1">return result.Records, nil</span>
}

func (c *Client) doRequest(method, path string, body []byte) (*http.Response, error) <span class="cov10" title="12">{
        var bodyReader io.Reader
        if body != nil </span><span class="cov8" title="7">{
                bodyReader = bytes.NewReader(body)
        }</span>

        <span class="cov10" title="12">req, err := http.NewRequest(method, c.baseURL+path, bodyReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create request: %w", err)
        }</span>

        <span class="cov10" title="12">req.Header.Set("Authorization", "Bearer "+c.authToken)
        if body != nil </span><span class="cov8" title="7">{
                req.Header.Set("Content-Type", "application/json")
        }</span>

        <span class="cov10" title="12">return c.client.Do(req)</span>
}

func (c *Client) parseError(resp *http.Response) error <span class="cov0" title="0">{
        body, _ := io.ReadAll(resp.Body)

        var errResp proto.ErrorResponse
        if err := json.Unmarshal(body, &amp;errResp); err == nil &amp;&amp; errResp.Message != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %s", errResp.Error, errResp.Message)
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(body))</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package coord implements the coordination server for tunnelmesh.
package coord

import (
        "encoding/json"
        "fmt"
        "net"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/rs/zerolog/log"
        "github.com/tunnelmesh/tunnelmesh/internal/config"
        "github.com/tunnelmesh/tunnelmesh/pkg/proto"
)

// Server is the coordination server that manages peer registration and discovery.
type Server struct {
        cfg      *config.ServerConfig
        mux      *http.ServeMux
        peers    map[string]*proto.Peer
        peersMu  sync.RWMutex
        ipAlloc  *ipAllocator
        dnsCache map[string]string // hostname -&gt; mesh IP
}

// ipAllocator manages IP address allocation from the mesh CIDR.
type ipAllocator struct {
        network *net.IPNet
        used    map[string]bool
        next    uint32
        mu      sync.Mutex
}

func newIPAllocator(cidr string) (*ipAllocator, error) <span class="cov6" title="14">{
        _, network, err := net.ParseCIDR(cidr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse CIDR: %w", err)
        }</span>

        <span class="cov6" title="14">return &amp;ipAllocator{
                network: network,
                used:    make(map[string]bool),
                next:    1, // Start from .1, skip .0 (network address)
        }, nil</span>
}

func (a *ipAllocator) allocate() (string, error) <span class="cov6" title="16">{
        a.mu.Lock()
        defer a.mu.Unlock()

        // Get the network address as uint32
        ip := a.network.IP.To4()
        if ip == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("only IPv4 supported")
        }</span>

        <span class="cov6" title="16">base := uint32(ip[0])&lt;&lt;24 | uint32(ip[1])&lt;&lt;16 | uint32(ip[2])&lt;&lt;8 | uint32(ip[3])

        // Find next available IP
        ones, bits := a.network.Mask.Size()
        maxHosts := uint32(1&lt;&lt;(bits-ones)) - 2 // Subtract network and broadcast

        for i := uint32(0); i &lt; maxHosts; i++ </span><span class="cov6" title="16">{
                candidate := base + a.next
                a.next++
                if a.next &gt; maxHosts </span><span class="cov0" title="0">{
                        a.next = 1
                }</span>

                <span class="cov6" title="16">candidateIP := net.IPv4(
                        byte(candidate&gt;&gt;24),
                        byte(candidate&gt;&gt;16),
                        byte(candidate&gt;&gt;8),
                        byte(candidate),
                )

                ipStr := candidateIP.String()
                if !a.used[ipStr] </span><span class="cov6" title="16">{
                        a.used[ipStr] = true
                        return ipStr, nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no available IP addresses")</span>
}

func (a *ipAllocator) release(ip string) <span class="cov2" title="2">{
        a.mu.Lock()
        defer a.mu.Unlock()
        delete(a.used, ip)
}</span>

// NewServer creates a new coordination server.
func NewServer(cfg *config.ServerConfig) (*Server, error) <span class="cov6" title="14">{
        ipAlloc, err := newIPAllocator(cfg.MeshCIDR)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create IP allocator: %w", err)
        }</span>

        <span class="cov6" title="14">srv := &amp;Server{
                cfg:      cfg,
                mux:      http.NewServeMux(),
                peers:    make(map[string]*proto.Peer),
                ipAlloc:  ipAlloc,
                dnsCache: make(map[string]string),
        }

        srv.setupRoutes()
        return srv, nil</span>
}

func (s *Server) setupRoutes() <span class="cov6" title="14">{
        s.mux.HandleFunc("/health", s.handleHealth)
        s.mux.HandleFunc("/api/v1/register", s.withAuth(s.handleRegister))
        s.mux.HandleFunc("/api/v1/peers", s.withAuth(s.handlePeers))
        s.mux.HandleFunc("/api/v1/peers/", s.withAuth(s.handlePeerByName))
        s.mux.HandleFunc("/api/v1/heartbeat", s.withAuth(s.handleHeartbeat))
        s.mux.HandleFunc("/api/v1/dns", s.withAuth(s.handleDNS))
}</span>

func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="31">{
        s.mux.ServeHTTP(w, r)
}</span>

func (s *Server) withAuth(next http.HandlerFunc) http.HandlerFunc <span class="cov10" title="70">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="30">{
                auth := r.Header.Get("Authorization")
                if auth == "" </span><span class="cov1" title="1">{
                        s.jsonError(w, "missing authorization header", http.StatusUnauthorized)
                        return
                }</span>

                // Expect "Bearer &lt;token&gt;"
                <span class="cov8" title="29">parts := strings.SplitN(auth, " ", 2)
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                        s.jsonError(w, "invalid authorization header", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="29">if parts[1] != s.cfg.AuthToken </span><span class="cov1" title="1">{
                        s.jsonError(w, "invalid token", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="28">next(w, r)</span>
        }
}

func (s *Server) handleHealth(w http.ResponseWriter, _ *http.Request) <span class="cov1" title="1">{
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"status": "ok"})
}</span>

func (s *Server) handleRegister(w http.ResponseWriter, r *http.Request) <span class="cov7" title="17">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                s.jsonError(w, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov7" title="17">var req proto.RegisterRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                s.jsonError(w, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov7" title="17">s.peersMu.Lock()
        defer s.peersMu.Unlock()

        // Check if peer already exists
        existing, exists := s.peers[req.Name]
        var meshIP string

        if exists </span><span class="cov1" title="1">{
                // Re-use existing IP
                meshIP = existing.MeshIP
        }</span> else<span class="cov6" title="16"> {
                // Allocate new IP
                var err error
                meshIP, err = s.ipAlloc.allocate()
                if err != nil </span><span class="cov0" title="0">{
                        s.jsonError(w, "failed to allocate IP: "+err.Error(), http.StatusInternalServerError)
                        return
                }</span>
        }

        <span class="cov7" title="17">peer := &amp;proto.Peer{
                Name:        req.Name,
                PublicKey:   req.PublicKey,
                PublicIPs:   req.PublicIPs,
                PrivateIPs:  req.PrivateIPs,
                SSHPort:     req.SSHPort,
                MeshIP:      meshIP,
                LastSeen:    time.Now(),
                Connectable: len(req.PublicIPs) &gt; 0,
        }

        s.peers[req.Name] = peer
        s.dnsCache[req.Name] = meshIP

        log.Info().
                Str("name", req.Name).
                Str("mesh_ip", meshIP).
                Msg("peer registered")

        resp := proto.RegisterResponse{
                MeshIP:   meshIP,
                MeshCIDR: s.cfg.MeshCIDR,
                Domain:   s.cfg.DomainSuffix,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(resp)</span>
}

func (s *Server) handlePeers(w http.ResponseWriter, r *http.Request) <span class="cov4" title="6">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                s.jsonError(w, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov4" title="6">s.peersMu.RLock()
        defer s.peersMu.RUnlock()

        peers := make([]proto.Peer, 0, len(s.peers))
        for _, p := range s.peers </span><span class="cov3" title="4">{
                peers = append(peers, *p)
        }</span>

        <span class="cov4" title="6">resp := proto.PeerListResponse{Peers: peers}
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(resp)</span>
}

func (s *Server) handlePeerByName(w http.ResponseWriter, r *http.Request) <span class="cov2" title="2">{
        // Extract peer name from path
        name := strings.TrimPrefix(r.URL.Path, "/api/v1/peers/")
        if name == "" </span><span class="cov0" title="0">{
                s.jsonError(w, "peer name required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov2" title="2">switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                s.peersMu.RLock()
                peer, exists := s.peers[name]
                s.peersMu.RUnlock()

                if !exists </span><span class="cov0" title="0">{
                        s.jsonError(w, "peer not found", http.StatusNotFound)
                        return
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(peer)</span>

        case http.MethodDelete:<span class="cov2" title="2">
                s.peersMu.Lock()
                peer, exists := s.peers[name]
                if exists </span><span class="cov2" title="2">{
                        s.ipAlloc.release(peer.MeshIP)
                        delete(s.peers, name)
                        delete(s.dnsCache, name)
                }</span>
                <span class="cov2" title="2">s.peersMu.Unlock()

                if !exists </span><span class="cov0" title="0">{
                        s.jsonError(w, "peer not found", http.StatusNotFound)
                        return
                }</span>

                <span class="cov2" title="2">log.Info().Str("name", name).Msg("peer deregistered")
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]string{"status": "ok"})</span>

        default:<span class="cov0" title="0">
                s.jsonError(w, "method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

func (s *Server) handleHeartbeat(w http.ResponseWriter, r *http.Request) <span class="cov2" title="2">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                s.jsonError(w, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov2" title="2">var req proto.HeartbeatRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                s.jsonError(w, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov2" title="2">s.peersMu.Lock()
        peer, exists := s.peers[req.Name]
        if exists </span><span class="cov2" title="2">{
                peer.LastSeen = time.Now()
        }</span>
        <span class="cov2" title="2">s.peersMu.Unlock()

        if !exists </span><span class="cov0" title="0">{
                s.jsonError(w, "peer not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov2" title="2">resp := proto.HeartbeatResponse{OK: true}
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(resp)</span>
}

func (s *Server) handleDNS(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                s.jsonError(w, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov1" title="1">s.peersMu.RLock()
        defer s.peersMu.RUnlock()

        records := make([]proto.DNSRecord, 0, len(s.dnsCache))
        for hostname, ip := range s.dnsCache </span><span class="cov2" title="2">{
                records = append(records, proto.DNSRecord{
                        Hostname: hostname,
                        MeshIP:   ip,
                })
        }</span>

        <span class="cov1" title="1">resp := proto.DNSUpdateNotification{Records: records}
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(resp)</span>
}

func (s *Server) jsonError(w http.ResponseWriter, message string, code int) <span class="cov2" title="2">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(code)
        json.NewEncoder(w).Encode(proto.ErrorResponse{
                Error:   http.StatusText(code),
                Code:    code,
                Message: message,
        })
}</span>

// ListenAndServe starts the coordination server.
func (s *Server) ListenAndServe() error <span class="cov0" title="0">{
        log.Info().Str("listen", s.cfg.Listen).Msg("starting coordination server")
        return http.ListenAndServe(s.cfg.Listen, s)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package dns implements a local DNS resolver for the mesh network.
package dns

import (
        "net"
        "strings"
        "sync"

        "github.com/miekg/dns"
        "github.com/rs/zerolog/log"
)

// Resolver is a local DNS server that resolves mesh hostnames.
type Resolver struct {
        suffix   string            // Domain suffix (e.g., ".mesh")
        ttl      uint32            // TTL for DNS responses
        records  map[string]string // hostname (without suffix) -&gt; IP
        mu       sync.RWMutex
        server   *dns.Server
        shutdown chan struct{}
}

// NewResolver creates a new DNS resolver.
func NewResolver(suffix string, ttl int) *Resolver <span class="cov6" title="8">{
        return &amp;Resolver{
                suffix:   suffix,
                ttl:      uint32(ttl),
                records:  make(map[string]string),
                shutdown: make(chan struct{}),
        }
}</span>

// AddRecord adds or updates a DNS record.
func (r *Resolver) AddRecord(hostname, ip string) <span class="cov7" title="9">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Store without suffix
        hostname = r.stripSuffix(hostname)
        r.records[hostname] = ip

        log.Debug().
                Str("hostname", hostname).
                Str("ip", ip).
                Msg("DNS record added")
}</span>

// RemoveRecord removes a DNS record.
func (r *Resolver) RemoveRecord(hostname string) <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        hostname = r.stripSuffix(hostname)
        delete(r.records, hostname)

        log.Debug().
                Str("hostname", hostname).
                Msg("DNS record removed")
}</span>

// UpdateRecords replaces all records with a new set.
func (r *Resolver) UpdateRecords(records map[string]string) <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        r.records = make(map[string]string, len(records))
        for hostname, ip := range records </span><span class="cov2" title="2">{
                hostname = r.stripSuffix(hostname)
                r.records[hostname] = ip
        }</span>

        <span class="cov1" title="1">log.Debug().
                Int("count", len(records)).
                Msg("DNS records updated")</span>
}

// Resolve looks up a hostname and returns its IP.
func (r *Resolver) Resolve(hostname string) (string, bool) <span class="cov7" title="12">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        hostname = r.stripSuffix(hostname)
        ip, ok := r.records[hostname]
        return ip, ok
}</span>

// ListRecords returns a copy of all records.
func (r *Resolver) ListRecords() map[string]string <span class="cov1" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        result := make(map[string]string, len(r.records))
        for k, v := range r.records </span><span class="cov2" title="2">{
                result[k] = v
        }</span>
        <span class="cov1" title="1">return result</span>
}

// ListenAndServe starts the DNS server.
func (r *Resolver) ListenAndServe(addr string) error <span class="cov2" title="2">{
        r.server = &amp;dns.Server{
                Addr: addr,
                Net:  "udp",
        }

        dns.HandleFunc(strings.TrimPrefix(r.suffix, "."), r.handleDNS)

        log.Info().
                Str("addr", addr).
                Str("suffix", r.suffix).
                Msg("starting DNS server")

        return r.server.ListenAndServe()
}</span>

// Shutdown stops the DNS server.
func (r *Resolver) Shutdown() error <span class="cov2" title="2">{
        if r.server != nil </span><span class="cov2" title="2">{
                return r.server.Shutdown()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *Resolver) handleDNS(w dns.ResponseWriter, req *dns.Msg) <span class="cov2" title="2">{
        resp := new(dns.Msg)
        resp.SetReply(req)
        resp.Authoritative = true

        for _, q := range req.Question </span><span class="cov2" title="2">{
                if q.Qtype != dns.TypeA &amp;&amp; q.Qtype != dns.TypeAAAA </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Extract hostname from FQDN
                <span class="cov2" title="2">hostname := strings.TrimSuffix(q.Name, ".")
                hostname = r.stripSuffix(hostname)

                ip, ok := r.Resolve(hostname)
                if !ok </span><span class="cov1" title="1">{
                        resp.Rcode = dns.RcodeNameError
                        continue</span>
                }

                <span class="cov1" title="1">if q.Qtype == dns.TypeA </span><span class="cov1" title="1">{
                        rr := &amp;dns.A{
                                Hdr: dns.RR_Header{
                                        Name:   q.Name,
                                        Rrtype: dns.TypeA,
                                        Class:  dns.ClassINET,
                                        Ttl:    r.ttl,
                                },
                                A: net.ParseIP(ip),
                        }
                        resp.Answer = append(resp.Answer, rr)
                }</span>
        }

        <span class="cov2" title="2">if len(req.Question) &gt; 0 &amp;&amp; len(resp.Answer) == 0 </span><span class="cov1" title="1">{
                resp.Rcode = dns.RcodeNameError
        }</span>

        <span class="cov2" title="2">w.WriteMsg(resp)</span>
}

func (r *Resolver) stripSuffix(hostname string) string <span class="cov10" title="26">{
        hostname = strings.TrimSuffix(hostname, ".")
        hostname = strings.TrimSuffix(hostname, r.suffix)
        return hostname
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package tunnel implements SSH tunnel management for peer-to-peer connections.
package tunnel

import (
        "fmt"
        "net"
        "sync"
        "time"

        "github.com/rs/zerolog/log"
        "golang.org/x/crypto/ssh"
)

const (
        // ChannelType is the SSH channel type for mesh data.
        ChannelType = "tunnelmesh-data"
)

// SSHServer handles incoming SSH connections.
type SSHServer struct {
        config *ssh.ServerConfig
}

// SSHConnection represents an established SSH connection.
type SSHConnection struct {
        Conn       *ssh.ServerConn
        Channels   &lt;-chan ssh.NewChannel
        Requests   &lt;-chan *ssh.Request
        PeerName   string
        RemoteAddr net.Addr
}

// NewSSHServer creates a new SSH server.
func NewSSHServer(hostKey ssh.Signer, authorizedKeys []ssh.PublicKey) *SSHServer <span class="cov10" title="3">{
        config := &amp;ssh.ServerConfig{
                PublicKeyCallback: func(conn ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) </span><span class="cov10" title="3">{
                        keyBytes := key.Marshal()
                        for _, authorized := range authorizedKeys </span><span class="cov10" title="3">{
                                if string(keyBytes) == string(authorized.Marshal()) </span><span class="cov10" title="3">{
                                        return &amp;ssh.Permissions{
                                                Extensions: map[string]string{
                                                        "pubkey-fp": ssh.FingerprintSHA256(key),
                                                },
                                        }, nil
                                }</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("unknown public key")</span>
                },
        }
        <span class="cov10" title="3">config.AddHostKey(hostKey)

        return &amp;SSHServer{config: config}</span>
}

// Accept accepts an incoming connection and performs SSH handshake.
func (s *SSHServer) Accept(conn net.Conn) (*SSHConnection, error) <span class="cov10" title="3">{
        sshConn, chans, reqs, err := ssh.NewServerConn(conn, s.config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SSH handshake failed: %w", err)
        }</span>

        // Handle out-of-band requests (keepalive, etc.)
        <span class="cov10" title="3">go ssh.DiscardRequests(reqs)

        log.Info().
                Str("remote", conn.RemoteAddr().String()).
                Str("user", sshConn.User()).
                Msg("SSH connection established")

        return &amp;SSHConnection{
                Conn:       sshConn,
                Channels:   chans,
                Requests:   reqs,
                RemoteAddr: conn.RemoteAddr(),
        }, nil</span>
}

// AddAuthorizedKey adds a public key to the authorized keys.
func (s *SSHServer) AddAuthorizedKey(key ssh.PublicKey) {<span class="cov0" title="0">
        // Note: In a production implementation, you'd want a more dynamic
        // authorized keys management. This is simplified for the initial version.
}</span>

// SSHClient handles outgoing SSH connections.
type SSHClient struct {
        signer  ssh.Signer
        hostKey ssh.PublicKey
}

// NewSSHClient creates a new SSH client.
func NewSSHClient(signer ssh.Signer, hostKey ssh.PublicKey) *SSHClient <span class="cov1" title="1">{
        return &amp;SSHClient{
                signer:  signer,
                hostKey: hostKey,
        }
}</span>

// Connect establishes an SSH connection to the given address.
func (c *SSHClient) Connect(addr string) (*ssh.Client, error) <span class="cov1" title="1">{
        config := &amp;ssh.ClientConfig{
                User: "tunnelmesh",
                Auth: []ssh.AuthMethod{
                        ssh.PublicKeys(c.signer),
                },
                HostKeyCallback: c.hostKeyCallback(),
                Timeout:         30 * time.Second,
        }

        client, err := ssh.Dial("tcp", addr, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SSH dial failed: %w", err)
        }</span>

        <span class="cov1" title="1">log.Info().
                Str("addr", addr).
                Msg("SSH connection established")

        return client, nil</span>
}

func (c *SSHClient) hostKeyCallback() ssh.HostKeyCallback <span class="cov1" title="1">{
        if c.hostKey == nil </span><span class="cov0" title="0">{
                // Insecure mode - accept any host key
                return ssh.InsecureIgnoreHostKey()
        }</span>

        <span class="cov1" title="1">return func(hostname string, remote net.Addr, key ssh.PublicKey) error </span><span class="cov1" title="1">{
                if string(key.Marshal()) != string(c.hostKey.Marshal()) </span><span class="cov0" title="0">{
                        return fmt.Errorf("host key mismatch")
                }</span>
                <span class="cov1" title="1">return nil</span>
        }
}

// Tunnel represents a bidirectional data tunnel over SSH.
type Tunnel struct {
        channel  ssh.Channel
        peerName string
        mu       sync.Mutex
        closed   bool
}

// NewTunnel creates a tunnel from an SSH channel.
func NewTunnel(channel ssh.Channel, peerName string) *Tunnel <span class="cov0" title="0">{
        return &amp;Tunnel{
                channel:  channel,
                peerName: peerName,
        }
}</span>

// Read reads data from the tunnel.
func (t *Tunnel) Read(p []byte) (int, error) <span class="cov0" title="0">{
        return t.channel.Read(p)
}</span>

// Write writes data to the tunnel.
func (t *Tunnel) Write(p []byte) (int, error) <span class="cov0" title="0">{
        return t.channel.Write(p)
}</span>

// Close closes the tunnel.
func (t *Tunnel) Close() error <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if t.closed </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">t.closed = true

        return t.channel.Close()</span>
}

// PeerName returns the name of the peer at the other end.
func (t *Tunnel) PeerName() string <span class="cov0" title="0">{
        return t.peerName
}</span>

// TunnelManager manages multiple tunnels to peers.
type TunnelManager struct {
        tunnels map[string]*Tunnel
        mu      sync.RWMutex
}

// NewTunnelManager creates a new tunnel manager.
func NewTunnelManager() *TunnelManager <span class="cov0" title="0">{
        return &amp;TunnelManager{
                tunnels: make(map[string]*Tunnel),
        }
}</span>

// Add adds a tunnel to the manager.
func (m *TunnelManager) Add(name string, tunnel *Tunnel) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Close existing tunnel if present
        if existing, ok := m.tunnels[name]; ok </span><span class="cov0" title="0">{
                existing.Close()
        }</span>

        <span class="cov0" title="0">m.tunnels[name] = tunnel
        log.Debug().Str("peer", name).Msg("tunnel added")</span>
}

// Get returns the tunnel for a peer.
func (m *TunnelManager) Get(name string) (*Tunnel, bool) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        tunnel, ok := m.tunnels[name]
        return tunnel, ok
}</span>

// Remove removes and closes a tunnel.
func (m *TunnelManager) Remove(name string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if tunnel, ok := m.tunnels[name]; ok </span><span class="cov0" title="0">{
                tunnel.Close()
                delete(m.tunnels, name)
                log.Debug().Str("peer", name).Msg("tunnel removed")
        }</span>
}

// List returns the names of all active tunnels.
func (m *TunnelManager) List() []string <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        names := make([]string, 0, len(m.tunnels))
        for name := range m.tunnels </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">return names</span>
}

// CloseAll closes all tunnels.
func (m *TunnelManager) CloseAll() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        for name, tunnel := range m.tunnels </span><span class="cov0" title="0">{
                tunnel.Close()
                delete(m.tunnels, name)
        }</span>
        <span class="cov0" title="0">log.Debug().Msg("all tunnels closed")</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package udpenc implements UDP-over-TCP encapsulation for tunnelmesh.
// It provides a simple framing protocol to send UDP datagrams over TCP streams.
//
// Frame format:
//   [2 bytes: payload length (big-endian)] [1 byte: protocol] [payload]
//
// This preserves packet boundaries when sending over TCP.
package udpenc

import (
        "encoding/binary"
        "fmt"
        "io"
        "sync"
)

// Protocol identifies the encapsulated protocol type.
type Protocol byte

const (
        // ProtoUDP indicates a UDP packet.
        ProtoUDP Protocol = 0x01
        // ProtoTCP indicates a TCP packet (for future use).
        ProtoTCP Protocol = 0x02
)

const (
        // HeaderSize is the size of the frame header (length + protocol).
        HeaderSize = 3
        // MaxPayloadSize is the maximum payload size (64KB - header).
        MaxPayloadSize = 65535 - HeaderSize
)

// Encoder writes framed data to an underlying writer.
type Encoder struct {
        w  io.Writer
        mu sync.Mutex
}

// NewEncoder creates a new encoder.
func NewEncoder(w io.Writer) *Encoder <span class="cov8" title="10">{
        return &amp;Encoder{w: w}
}</span>

// WriteFrame writes a single frame with the given protocol and payload.
func (e *Encoder) WriteFrame(proto Protocol, payload []byte) (int, error) <span class="cov9" title="12">{
        if len(payload) &gt; MaxPayloadSize </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("payload too large: %d &gt; %d", len(payload), MaxPayloadSize)
        }</span>

        <span class="cov9" title="11">e.mu.Lock()
        defer e.mu.Unlock()

        // Build frame: [length (2)][proto (1)][payload]
        frameLen := len(payload) + 1 // +1 for protocol byte
        header := make([]byte, HeaderSize)
        binary.BigEndian.PutUint16(header[0:2], uint16(frameLen))
        header[2] = byte(proto)

        // Write header
        if _, err := e.w.Write(header); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("write header: %w", err)
        }</span>

        // Write payload
        <span class="cov9" title="11">if len(payload) &gt; 0 </span><span class="cov8" title="10">{
                if _, err := e.w.Write(payload); err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("write payload: %w", err)
                }</span>
        }

        <span class="cov9" title="11">return HeaderSize + len(payload), nil</span>
}

// Decoder reads framed data from an underlying reader.
type Decoder struct {
        r  io.Reader
        mu sync.Mutex
}

// NewDecoder creates a new decoder.
func NewDecoder(r io.Reader) *Decoder <span class="cov9" title="12">{
        return &amp;Decoder{r: r}
}</span>

// ReadFrame reads a single frame and returns the protocol and payload.
func (d *Decoder) ReadFrame() (Protocol, []byte, error) <span class="cov10" title="14">{
        d.mu.Lock()
        defer d.mu.Unlock()

        // Read header
        header := make([]byte, HeaderSize)
        if _, err := io.ReadFull(d.r, header); err != nil </span><span class="cov3" title="2">{
                return 0, nil, err
        }</span>

        <span class="cov9" title="12">frameLen := binary.BigEndian.Uint16(header[0:2])
        proto := Protocol(header[2])

        // Read payload (frameLen includes protocol byte, which we already read)
        payloadLen := int(frameLen) - 1
        if payloadLen &lt; 0 </span><span class="cov0" title="0">{
                return 0, nil, fmt.Errorf("invalid frame length: %d", frameLen)
        }</span>

        <span class="cov9" title="12">if payloadLen == 0 </span><span class="cov1" title="1">{
                return proto, []byte{}, nil
        }</span>

        <span class="cov9" title="11">payload := make([]byte, payloadLen)
        if _, err := io.ReadFull(d.r, payload); err != nil </span><span class="cov1" title="1">{
                return 0, nil, fmt.Errorf("read payload: %w", err)
        }</span>

        <span class="cov8" title="10">return proto, payload, nil</span>
}

// FrameReader wraps a reader and provides frame-based reading.
// Each Read returns exactly one frame's worth of data.
type FrameReader struct {
        dec *Decoder
}

// NewFrameReader creates a new frame reader.
func NewFrameReader(r io.Reader) *FrameReader <span class="cov1" title="1">{
        return &amp;FrameReader{dec: NewDecoder(r)}
}</span>

// Read reads the next frame into p. The first byte is the protocol,
// followed by the payload.
func (fr *FrameReader) Read(p []byte) (int, error) <span class="cov1" title="1">{
        proto, payload, err := fr.dec.ReadFrame()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov1" title="1">needed := 1 + len(payload)
        if len(p) &lt; needed </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("buffer too small: %d &lt; %d", len(p), needed)
        }</span>

        <span class="cov1" title="1">p[0] = byte(proto)
        copy(p[1:], payload)
        return needed, nil</span>
}

// FrameWriter wraps a writer and provides frame-based writing.
// Each Write is sent as a single frame.
type FrameWriter struct {
        enc   *Encoder
        proto Protocol
}

// NewFrameWriter creates a new frame writer with a fixed protocol.
func NewFrameWriter(w io.Writer, proto Protocol) *FrameWriter <span class="cov1" title="1">{
        return &amp;FrameWriter{
                enc:   NewEncoder(w),
                proto: proto,
        }
}</span>

// Write writes p as a single frame.
func (fw *FrameWriter) Write(p []byte) (int, error) <span class="cov1" title="1">{
        _, err := fw.enc.WriteFrame(fw.proto, p)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov1" title="1">return len(p), nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package proto defines shared protocol messages for tunnelmesh.
package proto

import (
        "net"
        "time"
)

// Peer represents a node in the mesh network.
type Peer struct {
        Name        string    `json:"name"`
        PublicKey   string    `json:"public_key"`    // SSH public key fingerprint
        PublicIPs   []string  `json:"public_ips"`    // Externally reachable IPs
        PrivateIPs  []string  `json:"private_ips"`   // Internal network IPs
        SSHPort     int       `json:"ssh_port"`      // SSH server port
        MeshIP      string    `json:"mesh_ip"`       // Assigned mesh network IP (10.99.x.x)
        LastSeen    time.Time `json:"last_seen"`     // Last heartbeat time
        Connectable bool      `json:"connectable"`   // Can accept incoming connections
}

// RegisterRequest is sent by a peer to join the mesh.
type RegisterRequest struct {
        Name       string   `json:"name"`
        PublicKey  string   `json:"public_key"`
        PublicIPs  []string `json:"public_ips"`
        PrivateIPs []string `json:"private_ips"`
        SSHPort    int      `json:"ssh_port"`
}

// RegisterResponse is returned after successful registration.
type RegisterResponse struct {
        MeshIP   string `json:"mesh_ip"`     // Assigned mesh IP address
        MeshCIDR string `json:"mesh_cidr"`   // Full mesh CIDR for routing
        Domain   string `json:"domain"`      // Domain suffix (e.g., ".mesh")
}

// HeartbeatRequest is sent periodically to maintain presence.
type HeartbeatRequest struct {
        Name      string `json:"name"`
        PublicKey string `json:"public_key"`
}

// HeartbeatResponse is returned after successful heartbeat.
type HeartbeatResponse struct {
        OK bool `json:"ok"`
}

// PeerListResponse contains the list of all mesh peers.
type PeerListResponse struct {
        Peers []Peer `json:"peers"`
}

// DNSRecord represents a hostname to IP mapping.
type DNSRecord struct {
        Hostname string `json:"hostname"`
        MeshIP   string `json:"mesh_ip"`
}

// DNSUpdateNotification is sent when DNS records change.
type DNSUpdateNotification struct {
        Records []DNSRecord `json:"records"`
}

// ConnectionHint suggests how to connect to a peer.
type ConnectionHint struct {
        PeerName   string `json:"peer_name"`
        Strategy   string `json:"strategy"`    // "direct_public", "direct_private", "reverse"
        Address    string `json:"address"`     // IP:port to connect to
        RequireNAT bool   `json:"require_nat"` // True if NAT traversal needed
}

// ErrorResponse represents an API error.
type ErrorResponse struct {
        Error   string `json:"error"`
        Code    int    `json:"code"`
        Message string `json:"message"`
}

// GetLocalIPs returns the local IP addresses of the machine.
func GetLocalIPs() (public []string, private []string) <span class="cov1" title="1">{
        interfaces, err := net.Interfaces()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov1" title="1">for _, iface := range interfaces </span><span class="cov7" title="22">{
                // Skip loopback and down interfaces
                if iface.Flags&amp;net.FlagUp == 0 || iface.Flags&amp;net.FlagLoopback != 0 </span><span class="cov3" title="3">{
                        continue</span>
                }

                <span class="cov6" title="19">addrs, err := iface.Addrs()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="19">for _, addr := range addrs </span><span class="cov6" title="14">{
                        var ip net.IP
                        switch v := addr.(type) </span>{
                        case *net.IPNet:<span class="cov6" title="14">
                                ip = v.IP</span>
                        case *net.IPAddr:<span class="cov0" title="0">
                                ip = v.IP</span>
                        }

                        <span class="cov6" title="14">if ip == nil || ip.IsLoopback() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Only consider IPv4 for now
                        <span class="cov6" title="14">ip4 := ip.To4()
                        if ip4 == nil </span><span class="cov5" title="12">{
                                continue</span>
                        }

                        <span class="cov2" title="2">ipStr := ip4.String()
                        if isPrivateIP(ip4) </span><span class="cov1" title="1">{
                                private = append(private, ipStr)
                        }</span> else<span class="cov1" title="1"> {
                                public = append(public, ipStr)
                        }</span>
                }
        }

        <span class="cov1" title="1">return public, private</span>
}

// isPrivateIP checks if an IP is in a private range.
func isPrivateIP(ip net.IP) bool <span class="cov5" title="12">{
        private := []struct {
                start net.IP
                end   net.IP
        }{
                {net.IPv4(10, 0, 0, 0), net.IPv4(10, 255, 255, 255)},
                {net.IPv4(172, 16, 0, 0), net.IPv4(172, 31, 255, 255)},
                {net.IPv4(192, 168, 0, 0), net.IPv4(192, 168, 255, 255)},
        }

        for _, r := range private </span><span class="cov7" title="30">{
                if bytesGreaterOrEqual(ip, r.start) &amp;&amp; bytesGreaterOrEqual(r.end, ip) </span><span class="cov4" title="7">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}

func bytesGreaterOrEqual(a, b net.IP) bool <span class="cov8" title="53">{
        a = a.To4()
        b = b.To4()
        if a == nil || b == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="53">for i := 0; i &lt; 4; i++ </span><span class="cov10" title="94">{
                if a[i] &gt; b[i] </span><span class="cov7" title="25">{
                        return true
                }</span>
                <span class="cov9" title="69">if a[i] &lt; b[i] </span><span class="cov7" title="24">{
                        return false
                }</span>
        }
        <span class="cov3" title="4">return true</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package testutil provides shared test utilities and mocks for tunnelmesh tests.
package testutil

import (
        "crypto/ed25519"
        "crypto/rand"
        "encoding/pem"
        "io"
        "net"
        "os"
        "path/filepath"
        "testing"
        "time"

        "golang.org/x/crypto/ssh"
)

// TempDir creates a temporary directory for testing and returns a cleanup function.
func TempDir(t *testing.T) (string, func()) <span class="cov0" title="0">{
        t.Helper()
        dir, err := os.MkdirTemp("", "tunnelmesh-test-*")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create temp dir: %v", err)
        }</span>
        <span class="cov0" title="0">return dir, func() </span><span class="cov0" title="0">{
                os.RemoveAll(dir)
        }</span>
}

// TempFile creates a temporary file with the given content and returns its path.
func TempFile(t *testing.T, dir, name, content string) string <span class="cov0" title="0">{
        t.Helper()
        path := filepath.Join(dir, name)
        if err := os.WriteFile(path, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to write temp file: %v", err)
        }</span>
        <span class="cov0" title="0">return path</span>
}

// GenerateSSHKeyPair generates an ED25519 SSH key pair for testing.
// Returns the private key PEM bytes and the public key.
func GenerateSSHKeyPair(t *testing.T) ([]byte, ssh.PublicKey) <span class="cov0" title="0">{
        t.Helper()

        pub, priv, err := ed25519.GenerateKey(rand.Reader)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to generate key pair: %v", err)
        }</span>

        <span class="cov0" title="0">sshPub, err := ssh.NewPublicKey(pub)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create SSH public key: %v", err)
        }</span>

        // Marshal private key to OpenSSH format
        <span class="cov0" title="0">pemBlock, err := ssh.MarshalPrivateKey(priv, "")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to marshal private key: %v", err)
        }</span>

        // Encode to PEM format
        <span class="cov0" title="0">privBytes := pem.EncodeToMemory(pemBlock)

        return privBytes, sshPub</span>
}

// WriteSSHKeyPair writes an SSH key pair to files in the given directory.
// Returns paths to the private and public key files.
func WriteSSHKeyPair(t *testing.T, dir string) (privPath, pubPath string) <span class="cov0" title="0">{
        t.Helper()

        privBytes, pubKey := GenerateSSHKeyPair(t)

        privPath = filepath.Join(dir, "id_ed25519")
        pubPath = filepath.Join(dir, "id_ed25519.pub")

        if err := os.WriteFile(privPath, privBytes, 0600); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to write private key: %v", err)
        }</span>

        <span class="cov0" title="0">pubBytes := ssh.MarshalAuthorizedKey(pubKey)
        if err := os.WriteFile(pubPath, pubBytes, 0644); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to write public key: %v", err)
        }</span>

        <span class="cov0" title="0">return privPath, pubPath</span>
}

// FreePort returns an available TCP port on localhost.
func FreePort(t *testing.T) int <span class="cov0" title="0">{
        t.Helper()

        addr, err := net.ResolveTCPAddr("tcp", "localhost:0")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to resolve address: %v", err)
        }</span>

        <span class="cov0" title="0">l, err := net.ListenTCP("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to listen: %v", err)
        }</span>
        <span class="cov0" title="0">defer l.Close()

        return l.Addr().(*net.TCPAddr).Port</span>
}

// MockConn is a mock net.Conn for testing.
type MockConn struct {
        ReadData  []byte
        ReadErr   error
        WriteData []byte
        WriteErr  error
        Closed    bool
}

func (m *MockConn) Read(b []byte) (n int, err error) <span class="cov0" title="0">{
        if m.ReadErr != nil </span><span class="cov0" title="0">{
                return 0, m.ReadErr
        }</span>
        <span class="cov0" title="0">if len(m.ReadData) == 0 </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov0" title="0">n = copy(b, m.ReadData)
        m.ReadData = m.ReadData[n:]
        return n, nil</span>
}

func (m *MockConn) Write(b []byte) (n int, err error) <span class="cov0" title="0">{
        if m.WriteErr != nil </span><span class="cov0" title="0">{
                return 0, m.WriteErr
        }</span>
        <span class="cov0" title="0">m.WriteData = append(m.WriteData, b...)
        return len(b), nil</span>
}

func (m *MockConn) Close() error <span class="cov0" title="0">{
        m.Closed = true
        return nil
}</span>

func (m *MockConn) LocalAddr() net.Addr            <span class="cov0" title="0">{ return &amp;net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0} }</span>
func (m *MockConn) RemoteAddr() net.Addr           <span class="cov0" title="0">{ return &amp;net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0} }</span>
func (m *MockConn) SetDeadline(_ time.Time) error      <span class="cov0" title="0">{ return nil }</span>
func (m *MockConn) SetReadDeadline(_ time.Time) error  <span class="cov0" title="0">{ return nil }</span>
func (m *MockConn) SetWriteDeadline(_ time.Time) error <span class="cov0" title="0">{ return nil }</span>

// OpenFile opens a file for reading.
func OpenFile(path string) (io.ReadCloser, error) <span class="cov0" title="0">{
        return os.Open(path)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
